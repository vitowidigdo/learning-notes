- Kubernetes can upgrade replicas of container until 1000 or more
- Kubernetes used rolling-update, so that you can rollback if something goes wrong

## Kubernetes Architecture

1. Kubernetes cluster is a set of node (physical or virtual where kubernetes tools are installed)
2. Node is a worker machine, where container will be launched
3. Cluster is a set of nodes grouped together so that if one node fails, the other acts as a backup
4. Master/Control plane is like a swarm manager in kubernetes, they watch other worker (nodes)

<br>

---

<br>

## A few kubernetes key components

1. Master/Control Plane
2. Kubelet (tiny apps to communicate with the control plane also interacts with the node and container)
3. Pod (Container/Containers) => Each get internal IP Address => Abstraction of container
4. Etcd (key value store to store all your data)
5. Controller Manager => see health of pods, restarting the pods.
6. Scheduler => Assign pod to the slaves (see the resource allocation first)

<br>

---

<br>

- You access kubernetes in the cloud using kubectl
- Copy-paste the API endpoint setup (usually yaml file) and make it the kubeconfig file
- So that you can access master node

<br>

---

<br>

- Use Deployment file for a more verbose and specific than kubectl run => Abstraction of pods
- `kubectl apply -f (file name)`
- `kubectl get deployments` (get deployment file)
- `kubectl get pods -o wide` (get pods full name, ip address and assigned node)

<br>

---

<br>

- Replica is connected to the same service (**It is called replicaset**)
- Make new service file and kubectl apply -f (file name)
- `kubectl describe services (file name)` to get description of the service and pods
- To access via browser make external service (**Ingress**), for an internal pods used internal service

<br>

---

<br>

- ConfigMap => External links to the configuration of the apps (ex: links to the service like in .env file)
- Secret => Like ConfigMap but for secret data (credentials)

<br>

---

<br>

- Because data isn't persisted, kubernetes used volumes => (**attaches physical storage**)
  hard drive -> maybe in the local (same server node) or remote to the pods

<br>

---

<br>

- StatefulSet for a stateful apps. (ex: database) because db is complex using physical storage
- Because it is hard for making statefulSet, common practice is host db outside k8s cluster

<br>

---

<br>

- **Kube Proxy => important to have in slave nodes for forwarding request from service to the replicas**

<br>

---

<br>

## Master node components

1. API Server => cluster getaway, auth for the master
2. Scheduler
3. Etcd
4. Controller manager

## Worker components

1. Container runtime (ex: Docker)
2. Kubelet
3. Kube Proxy

<br>

## kubectl command line cheatsheet

<br>

### install hyperhit and minikube

`brew update`

`brew install hyperkit`

`brew install minikube`

`kubectl`

`minikube`

### create minikube cluster

`minikube start --vm-driver=hyperkit`

`kubectl get nodes`

`minikube status`

`kubectl version`

`kubectl cluster-info` => View info of cluster

### delete cluster and restart in debug mode

`minikube delete`

`minikube start --vm-driver=hyperkit --v=7 --alsologtostderr`

`minikube status`

### kubectl commands

`kubectl get nodes`

`kubectl get pod`

`kubectl get services`

`kubectl create deployment nginx-depl --image=nginx`

`kubectl get deployment`

`kubectl get replicaset`

`kubectl edit deployment nginx-depl`

### debugging

`kubectl logs {pod-name}`

`kubectl exec -it {pod-name} -- bin/bash`

### create mongo deployment

`kubectl create deployment mongo-depl --image=mongo`

`kubectl logs mongo-depl-{pod-name}`

`kubectl describe pod mongo-depl-{pod-name}`

### delete deplyoment

`kubectl delete deployment mongo-depl`

`kubectl delete deployment nginx-depl`

### create or edit config file

`vim nginx-deployment.yaml`

`kubectl apply -f nginx-deployment.yaml`

`kubectl get pod`

`kubectl get deployment`

### delete with config

`kubectl delete -f nginx-deployment.yaml`

### Metrics

`kubectl top` The kubectl top command returns current CPU and memory usage for a clusterâ€™s pods or nodes, or for a particular pod or node if specified.

### Check if objects in a namespace

`kubectl api-resources --namespaced=true`

### Check if objects not in a namespace

`kubectl api-resources --namespaced=false`

### Set permanent namespace preference

`kubectl config set-context --current --namespace=<insert-namespace-name-here>`

#### Validate it

`kubectl config view --minify | grep namespace:`

<br></br>

# Configuration Files

## 3 Specific parts of config file

1. Metadata => Name, etc.
2. Specification => Spec of the config file
3. Status => automatically generated by k8s

<br>

## Important part on config file

### Connection Deployment to Pods

- Using labels and selectors (matchLabels etc.)

### Ports

- Connect service to deployment so that service knows which port does listen to the container

**Configuration file of Deployment and Service usually in 1 file**

---

## Namespaces

### Namespace is a virtual cluster inside k8s cluster

4 default namespaces

1. kubernetes-dashboard => only on minikube
2. kube-system => For system processes, not intended for edit
3. kube-public => For publicly data (cluster information)
4. kube-node-lease => Heartbeat of nodes (determine availability)
5. default => created resources are here on default

But you also can create a new namespaces, using kubectl or config file

### Usage of namespace?

- Clustering all of your resources so that you can easily access it. (db namespace, monitoring namespace, etc.)
- If there are 2 teams and both deploy config with the same name, it'll overwrite it. Not if using namespace
- Staging and dev env (you don't have to deploy same resources twice)
- Restrict user so team A don't interfere team B env
- Limit resources

### Add namespace in file metadata

---

### Helm

- Package manager on k8s
- Helm charts => Bundle of yaml files (download from helm repo)
- Also become a templating engine for yaml files in k8s cluster
- Or the same deployment through different k8s cluster (dev, staging, prod)

---

### Persistent Volume

- Used for persist database (use cloud, nfs, or local/in the k8s cluster storage)
- In order to use the persistent volume, PVC (Persistent Volume Claim) is used
- The abstraction is:

1. Pod request volume using PVC
2. PVC tries to find a volume that satisfies the claim
3. PV has the actual storage backend
4. Volume is mounted to the pod

- If there are hundreds of PV that need to be made by the admins, it's get tedious, So intead use Storage Class
- SC make PV instantly if it's claim by PVC

### Claim must be in the same namespace as the pod

<br>

---

### Stateful Application and StatefulSet

- Stateful Application ex. all app where it's store or query data (db).
- Stateless App where all the data is completely new
- Stateless app usually connect to a stateful app

- While stateless is deploy using deployment, stateful using StatefulSet components

- Pod on stateful app has their own identity, so that they have master and slave pods.
- Only master pods can write data on PV (to prevent data inconsistency)

### Services

1. ClusterIP Services (Default)

- So that pod can communicate with each other
- Match pod with selector (on service) and labels (on pod)
- Also uses port (on service) and targetPort (on pods)
- Default load balancer on the pods

**If there are multiple ports, you have to name them**

2. Headless Services (ClusterIP: none)

- What if you want to directly access to the pods? Not just the service (ex. stateful apps master node)
- Directly access to the port using DNS Lookup and headless service
- Usually on stateful app there are 2 service (1 clusterIP and 1 Headless)
- ClusterIP so that other pod can access, headless for monitoring pod so that you can access pod directly

3. NodePort service type (not secure type attributes)

- So that external traffic can access the static port
- Pre defined range from 30000 - 32767
- Extension of ClusterIP type

4. LoadBalancer service type

- Native Cloud Provider Load Balancer can access service
- More secure than NodePort type
- Extension of nodePort type
